document.addEventListener("DOMContentLoaded", function() {
    // 1. Помечай свои изменения в комментариях и объясняй, чтобы было понятно

    /* 1.1. Также если комментируешь, то пиши перед комментарием номер.
    Если уже существует номер например 1 и 2, то можно написать 1.1. 
    Всё для удобства */

    /* 2. Вот эта штука "addEventListener" я не знаю, что это,
    но знаю, что это для того, чтобы сначала загрузилась страница,
    а потом уже начал работать код. */
    let userValues = []; // 3. Создал пустой массив для хранения значений
    let input = null; // 4. переменная, хранящая то, что пользователь написал в prompt


    for (let i = 1; i < 100; i++) {
        // 5. Цикл, который занесёт все значения, которые написал пользователь в массив
        input = prompt(`Напиши ${i} значение. Если всё, то "стоп" Максимум 100 значений`);
        
        if (input === "") {
            alert("Пожалуйста, введите значение!");
            continue;
        }
        // 6. Если пользователь ничего не ввёл, то будет предупредительное сообщение

        if (input === 'стоп') {
            break;
        }
        /* 7. Если ввёл стоп, то конец этого цикла (5.).
        В скобках я сослался на пункт 5, где написано про рассматриваемый цикл

        8. В этой конструкции (7.) в прошлой версии была проверка на null также (input === 'стоп' || input === null)
        Но в данном случае нам это не надо */

        userValues.push(input); // 8. Добавляю каждое значение в массив
    }

    for (let i = 0; i < userValues.length; i++) {
        /* 9. Цикл, чтобы группировать массив в подмассивы по парам. Если кол-во элементов нечетное,
        то последний кусок окажется тройкой (всмысле состоит из трёх элементов)*/
        if (i < userValues.length - 1) {
            userValues.splice(i, 2, [userValues[i], userValues[i + 1]]);
            /* 10. Прочитай про splice, если не знаешь. Очень полезная штука.
            Коротко, первый аргумент - с какого индекса начинаются изменения,
            второй аргумент - сколько элементов удаляется,
            третий аргумент - сами изменения*/
        } else if (userValues.length === 1 || userValues.length === 0) {
            break;
            /* 11. Если пользователь ввёл только одно значение, то ничего не произойдёт, всё бесполезно для одного значения
            12. В прошлой версии не было - (|| userValues.length === 0) */
        } else {
            userValues[userValues.length - 2].push(userValues.pop());
            /* 13. Иначе, то есть если оказался один элемент последний, то значит, что кол-во элементов нечетное.
            Тогда добавляем этот элемент в конец последней пары и получается тройка.*/
        }
    }

    /* 14. Удалил все функции так как в них ошибки. */
    /* 15. Надо бы создать функцию для сортировки значений внутри массива */
});
